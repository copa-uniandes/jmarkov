<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Usage &#8212; jMarkov 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=2709fde1"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to jMarkov’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="usage">
<h1>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h1>
<section id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Link to this heading">¶</a></h2>
<p>To use jMarkov, first install it using pip:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp gp-VirtualEnv">(.venv)</span> <span class="gp">$ </span>pip<span class="w"> </span>install<span class="w"> </span>jmarkov
</pre></div>
</div>
</section>
<section id="markov-chains">
<h2>Markov chains<a class="headerlink" href="#markov-chains" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="jmarkov.markov_chain.markov_chain">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jmarkov.markov_chain.</span></span><span class="sig-name descname"><span class="pre">markov_chain</span></span><a class="headerlink" href="#jmarkov.markov_chain.markov_chain" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="continuous-time-markov-chains">
<h2>Continuous-time Markov chains<a class="headerlink" href="#continuous-time-markov-chains" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="jmarkov.ctmc.ctmc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jmarkov.ctmc.</span></span><span class="sig-name descname"><span class="pre">ctmc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[1]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.ctmc.ctmc" title="Link to this definition">¶</a></dt>
<dd><p>Implements a finite continuous-time Markov chain (CTMC)</p>
<p>The chain is defined by its number of states, states, and a 
generator matrix. The class provides methods to compute both
stationary and transient metrics, as well as to check the 
chain properties (ergodicity).</p>
<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctmc.ctmc.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[1]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.ctmc.ctmc.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Creates a continuous-time Markov chain from its generator matrix</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctmc.ctmc.steady_state">
<span class="sig-name descname"><span class="pre">steady_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#jmarkov.ctmc.ctmc.steady_state" title="Link to this definition">¶</a></dt>
<dd><p>Computes the steady state distribution of the continuous-time Markov chain</p>
<p>Computes the steady state probability distribution by replacing one of the 
matrix equations with a normalizing equation that ensures the result is a 
probability distribution.</p>
<p>Returns the stationary probability distribution in array form</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctmc.ctmc.transient_probabilities">
<span class="sig-name descname"><span class="pre">transient_probabilities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#jmarkov.ctmc.ctmc.transient_probabilities" title="Link to this definition">¶</a></dt>
<dd><p>Computes the transient distribution at time t with initial state alpha</p>
<p>Computes alpha*exp(Q*t)*ones to obtain the probability distribution
at time t given the initial probability distribution alpha</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctmc.ctmc.first_passage_time">
<span class="sig-name descname"><span class="pre">first_passage_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.ctmc.ctmc.first_passage_time" title="Link to this definition">¶</a></dt>
<dd><p>Computes the expected first passage time to a target state from a start state.</p>
<p>This method calculates the expected number of steps required for the Markov chain to reach
the specified target state from the start state by creating a sub-matrix of the generator matrix with the target removed.</p>
<p>Returns the expected steps to reach the target state from any start state (except target) in array form</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctmc.ctmc.occupation_time">
<span class="sig-name descname"><span class="pre">occupation_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.ctmc.ctmc.occupation_time" title="Link to this definition">¶</a></dt>
<dd><p>Computes the expected occupation time in each state until time T.</p>
<p>This method computes the expected time the chain spends in each state,
from time 0 until time T. To this end it uses the embedded matrix and 
the uniformization method.</p>
<p>Returns the expected time in each state from 0 to T</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctmc.ctmc.is_irreducible">
<span class="sig-name descname"><span class="pre">is_irreducible</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.ctmc.ctmc.is_irreducible" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the given continous-time Markov Chain is irreducible.</p>
<p>This method determines if the continous-time Markov Chain is irreducible by checking if, starting in
any state, it is possible to reach any other state in a sequence of transitions.</p>
<p>Returns a boolean</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctmc.ctmc.is_ergodic">
<span class="sig-name descname"><span class="pre">is_ergodic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.ctmc.ctmc.is_ergodic" title="Link to this definition">¶</a></dt>
<dd><p>Checks if a given continous-time Markov Chain is ergodic.</p>
<p>Given that a finite continous-time Markov Chain is ergodic if it is irreducible, this
method checks if it is irreducible to determine if the provided chain is ergodic or not.</p>
</dd></dl>

</dd></dl>

</section>
<section id="discrete-time-markov-chains">
<h2>Discrete-time Markov chains<a class="headerlink" href="#discrete-time-markov-chains" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="jmarkov.dtmc.dtmc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jmarkov.dtmc.</span></span><span class="sig-name descname"><span class="pre">dtmc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[1]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.dtmc.dtmc" title="Link to this definition">¶</a></dt>
<dd><p>Implements a finite discrete-time Markov chain (CTMC)</p>
<p>The chain is defined by its number of states, states, and a 
transition matrix. The class provides methods to compute both
stationary and transient metrics, as well as to check the 
chain properties (aperiodicity and ergodicity).</p>
<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.dtmc.dtmc.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[1]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.dtmc.dtmc.__init__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.dtmc.dtmc.steady_state">
<span class="sig-name descname"><span class="pre">steady_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#jmarkov.dtmc.dtmc.steady_state" title="Link to this definition">¶</a></dt>
<dd><p>Computes the steady state distribution of the discrete-time Markov chain</p>
<p>Computes the steady state probability distribution by replacing one of the 
matrix equations with a normalizing equation that ensures the result is a 
probability distribution.</p>
<p>Returns the stationary probability distribution in array form</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.dtmc.dtmc.transient_probabilities">
<span class="sig-name descname"><span class="pre">transient_probabilities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.dtmc.dtmc.transient_probabilities" title="Link to this definition">¶</a></dt>
<dd><p>Computes the transient distribution at transition n with initial state alpha</p>
<p>Computes alpha*(P^n)*ones to obtain the probability distribution
at time/transition n given the initial probability distribution alpha</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.dtmc.dtmc.period">
<span class="sig-name descname"><span class="pre">period</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.dtmc.dtmc.period" title="Link to this definition">¶</a></dt>
<dd><p>Computes the period of a discrete-time Markov Chain.</p>
<p>This method calculates the period of a discrete-time Markov Chain by iterating a total of N steps, where N represents
the number of states that the chain has. In each k-th iteration, the chain is elevated to the k-th power to compute the
transient probabilities in the k-th step. If one of the elementsin in the diagonal of the resulting matrix is greater than 0,
the chain can potentially have a period k. The period of the matrix will be the Greatest Common Divisor (GCD) between the
potential new period of the matrix in the k-th iteration and the current GCD before the k-th iteration.</p>
<p>Returns the period of the chain as an int</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.dtmc.dtmc.is_irreducible">
<span class="sig-name descname"><span class="pre">is_irreducible</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.dtmc.dtmc.is_irreducible" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the given discrete-time Markov Chain is irreducible.</p>
<p>This method determines if the discrete-time Markov Chain is irreducible by checking if, starting in
any state, it is possible to reach any other state in a sequence of transitions.</p>
<p>Returns a boolean</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.dtmc.dtmc.is_ergodic">
<span class="sig-name descname"><span class="pre">is_ergodic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.dtmc.dtmc.is_ergodic" title="Link to this definition">¶</a></dt>
<dd><p>Checks if a given discrete-time Markov Chain is ergodic.</p>
<p>Given that a finite discrete-time Markov Chain is ergodic if it is aperiodic and irreducible, this
method checks if both conditions are met to determine if the provided chain is ergodic or not.</p>
<p>Returns a boolean</p>
</dd></dl>

</dd></dl>

</section>
<section id="infinite-continuous-time-birth-death-markov-chains">
<h2>Infinite Continuous-time Birth-death Markov chains<a class="headerlink" href="#infinite-continuous-time-birth-death-markov-chains" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="jmarkov.ctbd.ctbd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jmarkov.ctbd.</span></span><span class="sig-name descname"><span class="pre">ctbd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">birth_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">death_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.ctbd.ctbd" title="Link to this definition">¶</a></dt>
<dd><p>Implements an infinite continuous-time birth-death (CTBD) Markov chain</p>
<p>The CTBD chain is defined by its birth and death rates, which themselves
define the number of states, states, and the generator matrix. 
The representation in this class relies on the birth and death rates between
states 0 to K, and it is assumed that from state K onwards the birth and death rates
have the same values.  
The class provides methods to compute both
stationary and transient metrics, as well as to check the 
chain properties (ergodicity).</p>
<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctbd.ctbd.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">birth_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">death_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.ctbd.ctbd.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Creates a continuous-time Birth-Death Markov chain from its birth and death rates</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctbd.ctbd._check_birth_death_rates">
<span class="sig-name descname"><span class="pre">_check_birth_death_rates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">birth_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">death_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.ctbd.ctbd._check_birth_death_rates" title="Link to this definition">¶</a></dt>
<dd><p>Checks that all birth and death rates are positive</p>
<p>Checks that arrays of birth and death rates have the same nonzero size</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctbd.ctbd.steady_state">
<span class="sig-name descname"><span class="pre">steady_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#jmarkov.ctbd.ctbd.steady_state" title="Link to this definition">¶</a></dt>
<dd><p>Computes the steady state distribution of the continuous-time BD Markov chain</p>
<p>Computes the steady state probability distribution by solving the balance equations
to first find pi0 and then the remaining entries of the distribution.</p>
<p>n is an optional parameter to specify the length of the steady state distribution 
vector. It should be at least as large as the size of the birth and death rate arrays. 
If not specified, the returned vector is equal to the length of the birth and death arrays.</p>
<p>Returns the stationary probability distribution in array form</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctbd.ctbd.is_irreducible">
<span class="sig-name descname"><span class="pre">is_irreducible</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.ctbd.ctbd.is_irreducible" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the given continous-time BD Markov Chain is irreducible.</p>
<p>This method determines if the birth-death continous-time Markov Chain is irreducible 
by checking if, starting in any state, it is possible to reach any other state 
in a sequence of transitions.</p>
<p>Returns a boolean</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.ctbd.ctbd.is_ergodic">
<span class="sig-name descname"><span class="pre">is_ergodic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.ctbd.ctbd.is_ergodic" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the given continous-time BD Markov Chain is ergodic.</p>
<p>Given that this chain is infinite, we first check if is irreducible 
and next check if the last birth rate is smaller than the last 
death rate, a condition that ensures ergodicity.</p>
</dd></dl>

</dd></dl>

</section>
<section id="finite-continuous-time-birth-death-markov-chains">
<h2>Finite Continuous-time Birth-death Markov chains<a class="headerlink" href="#finite-continuous-time-birth-death-markov-chains" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="jmarkov.finite_ctbd.finite_ctbd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jmarkov.finite_ctbd.</span></span><span class="sig-name descname"><span class="pre">finite_ctbd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">birth_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">death_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.finite_ctbd.finite_ctbd" title="Link to this definition">¶</a></dt>
<dd><p>Implements a finite continuous-time birth-death (CTBD) Markov chain</p>
<p>The finite CTBD chain is defined by its birth and death rates, which themselves
define the number of states, states, and the generator matrix. 
The representation in this class relies on the birth and death rates between
states 0 to K.  
The class provides methods to compute stationary metrics, as well as to check the 
chain properties (ergodicity).</p>
<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.finite_ctbd.finite_ctbd.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">birth_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">death_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.finite_ctbd.finite_ctbd.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Creates a finite  continuous-time Birth-Death Markov chain from its birth and death rates</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.finite_ctbd.finite_ctbd._check_birth_death_rates">
<span class="sig-name descname"><span class="pre">_check_birth_death_rates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">birth_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">death_rates</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.finite_ctbd.finite_ctbd._check_birth_death_rates" title="Link to this definition">¶</a></dt>
<dd><p>Checks that all birth and death rates are positive</p>
<p>Checks that arrays of birth and death rates have the same nonzero size</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.finite_ctbd.finite_ctbd.steady_state">
<span class="sig-name descname"><span class="pre">steady_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#jmarkov.finite_ctbd.finite_ctbd.steady_state" title="Link to this definition">¶</a></dt>
<dd><p>Computes the steady state distribution of the continuous-time BD Markov chain</p>
<p>Computes the steady state probability distribution by solving the balance equations
to first find pi0 and then the remaining entries of the distribution.</p>
<p>Returns the stationary probability distribution in array form</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.finite_ctbd.finite_ctbd.is_irreducible">
<span class="sig-name descname"><span class="pre">is_irreducible</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.finite_ctbd.finite_ctbd.is_irreducible" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the given continous-time BD Markov Chain is irreducible.</p>
<p>This method determines if the birth-death continous-time Markov Chain is irreducible 
by checking if, starting in any state, it is possible to reach any other state 
in a sequence of transitions.</p>
<p>Returns a boolean</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.finite_ctbd.finite_ctbd.is_ergodic">
<span class="sig-name descname"><span class="pre">is_ergodic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.finite_ctbd.finite_ctbd.is_ergodic" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the given continous-time BD Markov Chain is ergodic.</p>
<p>Given that a finite continous-time Markov Chain is ergodic if it is irreducible, this
method checks if it is irreducible to determine if the provided chain is ergodic or not.</p>
</dd></dl>

</dd></dl>

</section>
<section id="queueing-systems">
<h2>Queueing systems<a class="headerlink" href="#queueing-systems" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="jmarkov.queue.mmk.mmk">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jmarkov.queue.mmk.</span></span><span class="sig-name descname"><span class="pre">mmk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ser_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.queue.mmk.mmk" title="Link to this definition">¶</a></dt>
<dd><p>Implements an M/M/k queue and computes steady state metrics</p>
<p>The M/M/k queue has exponential interarrival times, with rate arr_rate,
exponential service times, with ser_rate,
and k servers in parallel.</p>
<p>The class builds a birth-death chain that models this queue and uses 
the steady state probability distribution of the chain to compute
measures of performance such as mean number of entities in the system,
in queue, in service, and the mean time in the system, in queue, and in service.</p>
<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmk.mmk.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ser_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.queue.mmk.mmk.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Creates an M/M/k queue with k servers, arr_rate arrival rate and ser_rate service rate</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmk.mmk.mean_number_entities">
<span class="sig-name descname"><span class="pre">mean_number_entities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmk.mmk.mean_number_entities" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in the system in steady state</p>
<p>A birth-death chain is built and its stattionary probability distribution is used 
to compute the mean number of entities in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmk.mmk.mean_number_entities_queue">
<span class="sig-name descname"><span class="pre">mean_number_entities_queue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmk.mmk.mean_number_entities_queue" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in queue in steady state</p>
<p>A birth-death chain is built and its stattionary probability distribution is used 
to compute the mean number of entities in queue in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmk.mmk.mean_number_entities_service">
<span class="sig-name descname"><span class="pre">mean_number_entities_service</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmk.mmk.mean_number_entities_service" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in service in steady state</p>
<p>A birth-death chain is built and its stattionary probability distribution is used 
to compute the mean number of entities in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmk.mmk.mean_time_system">
<span class="sig-name descname"><span class="pre">mean_time_system</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmk.mmk.mean_time_system" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in the system in steady state</p>
<p>A birth-death chain is built and its stationary probability distribution is used 
to compute the mean number of entities in the system in steady state, which is 
then used with Little’s Law to obtain the mean time in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmk.mmk.mean_time_queue">
<span class="sig-name descname"><span class="pre">mean_time_queue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmk.mmk.mean_time_queue" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in the queue in steady state</p>
<p>A birth-death chain is built and its stationary probability distribution is used 
to compute the mean number of entities in the queue in steady state, which is 
then used with Little’s Law to obtain the mean time in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmk.mmk.mean_time_service">
<span class="sig-name descname"><span class="pre">mean_time_service</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmk.mmk.mean_time_service" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in service</p>
<p>A simple relation is used to obtain the mean service time</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmk.mmk.is_stable">
<span class="sig-name descname"><span class="pre">is_stable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#jmarkov.queue.mmk.mmk.is_stable" title="Link to this definition">¶</a></dt>
<dd><p>Returns True if the queue is stable, False otherwise</p>
<p>This queue is stable if the arrival rate is smaller than the 
maximum service rate</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="jmarkov.queue.mmkn.mmkn">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jmarkov.queue.mmkn.</span></span><span class="sig-name descname"><span class="pre">mmkn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ser_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.queue.mmkn.mmkn" title="Link to this definition">¶</a></dt>
<dd><p>Implements an M/M/k/n queue and computes steady state metrics</p>
<p>The M/M/k/n queue has exponential interarrival times, with rate arr_rate,
exponential service times, with ser_rate,
k servers in parallel, and
n places in total (n-k for waiting).</p>
<p>The class builds a birth-death chain that models this queue and uses 
the steady state probability distribution of the chain to compute
measures of performance such as mean number of entities in the system,
in queue, in service, and the mean time in the system, in queue, and in service.</p>
<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmkn.mmkn.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ser_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.queue.mmkn.mmkn.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Creates an M/M/k/n queue with k servers, arr_rate arrival rate, ser_rate service rate, and capacity n</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmkn.mmkn.mean_number_entities">
<span class="sig-name descname"><span class="pre">mean_number_entities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmkn.mmkn.mean_number_entities" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in the system in steady state</p>
<p>A birth-death chain is built and its stationary probability distribution is used 
to compute the mean number of entities in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmkn.mmkn.mean_number_entities_queue">
<span class="sig-name descname"><span class="pre">mean_number_entities_queue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmkn.mmkn.mean_number_entities_queue" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in queue in steady state</p>
<p>A birth-death chain is built and its stattionary probability distribution is used 
to compute the mean number of entities in queue in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmkn.mmkn.mean_number_entities_service">
<span class="sig-name descname"><span class="pre">mean_number_entities_service</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmkn.mmkn.mean_number_entities_service" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in service in steady state</p>
<p>A birth-death chain is built and its stattionary probability distribution is used 
to compute the mean number of entities in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmkn.mmkn.mean_time_system">
<span class="sig-name descname"><span class="pre">mean_time_system</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmkn.mmkn.mean_time_system" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in the system in steady state</p>
<p>A birth-death chain is built and its stationary probability distribution is used 
to compute the mean number of entities in the system in steady state, which is 
then used with Little’s Law to obtain the mean time in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmkn.mmkn.mean_time_queue">
<span class="sig-name descname"><span class="pre">mean_time_queue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmkn.mmkn.mean_time_queue" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in the queue in steady state</p>
<p>A birth-death chain is built and its stationary probability distribution is used 
to compute the mean number of entities in the queue in steady state, which is 
then used with Little’s Law to obtain the mean time in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mmkn.mmkn.mean_time_service">
<span class="sig-name descname"><span class="pre">mean_time_service</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mmkn.mmkn.mean_time_service" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in service</p>
<p>A birth-death chain is built and its stationary probability distribution is used 
to compute the mean number of entities in the queue in steady state, which is 
then used with Little’s Law to obtain the mean time in the system in steady state</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="jmarkov.queue.mg1.mg1">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jmarkov.queue.mg1.</span></span><span class="sig-name descname"><span class="pre">mg1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ser_mean</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ser_var</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.queue.mg1.mg1" title="Link to this definition">¶</a></dt>
<dd><p>Implements an M/G/1 queue and computes several performance metrics</p>
<p>The M/G/1 queue has exponential interarrival times, with rate arr_rate,
and one server with service times that follow any probability distribution, 
specified by its mean ser_mean and variances ser_var.</p>
<p>The class employs the Pollaczek–Khinchine formula to compute measures
of performance such as mean number of entities in the system, in queue, in service, 
and the mean time in the system, in queue, and in service, as well, as server utilization.</p>
<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mg1.mg1.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ser_mean</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ser_var</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.queue.mg1.mg1.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Creates an M/G/1 queue with 1 server, arr_rate arrival rate, 
ser_mean service time mean rate and ser_var service time variance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mg1.mg1.mean_number_entities">
<span class="sig-name descname"><span class="pre">mean_number_entities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mg1.mg1.mean_number_entities" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mg1.mg1.mean_number_entities_queue">
<span class="sig-name descname"><span class="pre">mean_number_entities_queue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mg1.mg1.mean_number_entities_queue" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in queue in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mg1.mg1.mean_number_entities_service">
<span class="sig-name descname"><span class="pre">mean_number_entities_service</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mg1.mg1.mean_number_entities_service" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in service in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mg1.mg1.mean_time_system">
<span class="sig-name descname"><span class="pre">mean_time_system</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mg1.mg1.mean_time_system" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mg1.mg1.mean_time_queue">
<span class="sig-name descname"><span class="pre">mean_time_queue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mg1.mg1.mean_time_queue" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in the queue in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.mg1.mg1.mean_time_service">
<span class="sig-name descname"><span class="pre">mean_time_service</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.mg1.mg1.mean_time_service" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in service</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="jmarkov.queue.gginf.gginf">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jmarkov.queue.gginf.</span></span><span class="sig-name descname"><span class="pre">gginf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ser_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.queue.gginf.gginf" title="Link to this definition">¶</a></dt>
<dd><p>Implements an G/G/Inf queue and computes several performance metrics</p>
<p>The G/G/Inf queue has interarrival and service times that follow any probability 
distribution, with arr_rate and ser_rate (respectively), and the number of servers, 
the system capacity and the population are infinite.</p>
<p>The class uses the fact that the infinite number of servers simplifies may of the 
metrics to obtain closed-form results for many average performance metrics.</p>
<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.gginf.gginf.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ser_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.queue.gginf.gginf.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Creates an G/G/Inf queue with infinite servers, arr_rate arrival rate and ser_rate service rate</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.gginf.gginf.mean_number_entities">
<span class="sig-name descname"><span class="pre">mean_number_entities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.gginf.gginf.mean_number_entities" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.gginf.gginf.mean_number_entities_queue">
<span class="sig-name descname"><span class="pre">mean_number_entities_queue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.gginf.gginf.mean_number_entities_queue" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in queue in steady state</p>
<p>As the queue has infinite servers, there is never a line in queue</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.gginf.gginf.mean_number_entities_service">
<span class="sig-name descname"><span class="pre">mean_number_entities_service</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.gginf.gginf.mean_number_entities_service" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean number of entities in service in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.gginf.gginf.mean_time_system">
<span class="sig-name descname"><span class="pre">mean_time_system</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.gginf.gginf.mean_time_system" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in the system in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.gginf.gginf.mean_time_queue">
<span class="sig-name descname"><span class="pre">mean_time_queue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.gginf.gginf.mean_time_queue" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in the queue in steady state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.queue.gginf.gginf.mean_time_service">
<span class="sig-name descname"><span class="pre">mean_time_service</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#jmarkov.queue.gginf.gginf.mean_time_service" title="Link to this definition">¶</a></dt>
<dd><p>Computes the mean time in service</p>
</dd></dl>

</dd></dl>

</section>
<section id="discrete-time-markov-decision-processes-mdps">
<h2>Discrete-time Markov Decision Processes (MDPs)<a class="headerlink" href="#discrete-time-markov-decision-processes-mdps" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="jmarkov.mdp.dtmdp.dtmdp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jmarkov.mdp.dtmdp.</span></span><span class="sig-name descname"><span class="pre">dtmdp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transition_matrices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immediate_returns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discount_factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.mdp.dtmdp.dtmdp" title="Link to this definition">¶</a></dt>
<dd><p>Implements a Markov decision process (MDP)</p>
<p>The process is defined by its number of states, states, number of actions, actions,
the immediate returns of implementing each action and a transition matrix for each action. 
The class provides methods to solve MDPs and to compute the expected value of the optimal policy.</p>
<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.mdp.dtmdp.dtmdp.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transition_matrices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immediate_returns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discount_factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.mdp.dtmdp.dtmdp.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Creates a markov decision process from its transition matrices, immediate returns and discount factor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.mdp.dtmdp.dtmdp._check_transition_matrices">
<span class="sig-name descname"><span class="pre">_check_transition_matrices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.mdp.dtmdp.dtmdp._check_transition_matrices" title="Link to this definition">¶</a></dt>
<dd><p>Checks that all matrices are stochastic</p>
<p>Checks that all row sums are equal to one and all elements are non negative</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.mdp.dtmdp.dtmdp._check_immediate_returns">
<span class="sig-name descname"><span class="pre">_check_immediate_returns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.mdp.dtmdp.dtmdp._check_immediate_returns" title="Link to this definition">¶</a></dt>
<dd><p>Checks that the immediate returns are valid and dimensionally-coherent</p>
<p>Checks that immediate return array has dimensions length of states x length of actions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.mdp.dtmdp.dtmdp._check_discount_factor">
<span class="sig-name descname"><span class="pre">_check_discount_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.mdp.dtmdp.dtmdp._check_discount_factor" title="Link to this definition">¶</a></dt>
<dd><p>Checks that the discount factor is valid</p>
<p>Checks that discount factor is a number equal to or greater than 0 and  less than 1</p>
</dd></dl>

</dd></dl>

</section>
<section id="discrete-time-stochastic-dynamic-programming-sdps">
<h2>Discrete-time Stochastic Dynamic Programming (SDPs)<a class="headerlink" href="#discrete-time-stochastic-dynamic-programming-sdps" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="jmarkov.sdp.dtsdp.dtsdp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">jmarkov.sdp.dtsdp.</span></span><span class="sig-name descname"><span class="pre">dtsdp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">periods</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transition_matrices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immediate_returns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discount_factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.sdp.dtsdp.dtsdp" title="Link to this definition">¶</a></dt>
<dd><p>Implements an Stochastic Decision Process (SDP)</p>
<p>The process is defined by its time horizon, number of states, states, number of actions, actions,
the immediate returns of implementing each action and a transition matrix for each action. 
The class provides methods to solve SDPs and to compute the expected value of the optimal policy.</p>
<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.sdp.dtsdp.dtsdp.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">periods</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transition_matrices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">immediate_returns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discount_factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.sdp.dtsdp.dtsdp.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Creates a markov decision process from its transition matrices, immediate returns and discount factor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.sdp.dtsdp.dtsdp._check_transition_matrices">
<span class="sig-name descname"><span class="pre">_check_transition_matrices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.sdp.dtsdp.dtsdp._check_transition_matrices" title="Link to this definition">¶</a></dt>
<dd><p>Checks that all matrices are stochastic</p>
<p>Checks that all row sums are equal to one and all elements are non negative</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.sdp.dtsdp.dtsdp._check_immediate_returns">
<span class="sig-name descname"><span class="pre">_check_immediate_returns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">periods</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.sdp.dtsdp.dtsdp._check_immediate_returns" title="Link to this definition">¶</a></dt>
<dd><p>Checks that the immediate returns are valid and dimensionally-coherent</p>
<p>Checks that immediate return array has dimensions length of epochs x length of states x length of actions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.sdp.dtsdp.dtsdp._check_discount_factor">
<span class="sig-name descname"><span class="pre">_check_discount_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.sdp.dtsdp.dtsdp._check_discount_factor" title="Link to this definition">¶</a></dt>
<dd><p>Checks that the discount factor is valid</p>
<p>Checks that discount factor is a number equal to or greater than 0 and  less than 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.sdp.dtsdp.dtsdp._check_time_period">
<span class="sig-name descname"><span class="pre">_check_time_period</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">periods</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.sdp.dtsdp.dtsdp._check_time_period" title="Link to this definition">¶</a></dt>
<dd><p>”
Checks that the time period is valid</p>
<p>Checks that the time period is a number greater than 0</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="jmarkov.sdp.dtsdp.dtsdp.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">minimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#jmarkov.sdp.dtsdp.dtsdp.solve" title="Link to this definition">¶</a></dt>
<dd><p>Solves SDP’s with backward iteration</p>
<p>Returns the expected value of following the optimal policy at each state and the optimal policy for each state</p>
</dd></dl>

</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">jMarkov</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#markov-chains">Markov chains</a></li>
<li class="toctree-l2"><a class="reference internal" href="#continuous-time-markov-chains">Continuous-time Markov chains</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discrete-time-markov-chains">Discrete-time Markov chains</a></li>
<li class="toctree-l2"><a class="reference internal" href="#infinite-continuous-time-birth-death-markov-chains">Infinite Continuous-time Birth-death Markov chains</a></li>
<li class="toctree-l2"><a class="reference internal" href="#finite-continuous-time-birth-death-markov-chains">Finite Continuous-time Birth-death Markov chains</a></li>
<li class="toctree-l2"><a class="reference internal" href="#queueing-systems">Queueing systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discrete-time-markov-decision-processes-mdps">Discrete-time Markov Decision Processes (MDPs)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discrete-time-stochastic-dynamic-programming-sdps">Discrete-time Stochastic Dynamic Programming (SDPs)</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to jMarkov’s documentation!</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, COPA@Uniandes.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/usage.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>